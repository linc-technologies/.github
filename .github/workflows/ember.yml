name: "Ember"

on:
  workflow_call:
    # TODO: Deprecate these as we move to helm
    inputs:
      DEPLOYMENT:
        description: "The name of the Kubernetes deployment to deploy to, ex: app-app-deployment"
        type: string
        required: true
      CONTAINER:
        description: "The name of the container within the Kubernetes deployment to patch, ex: app-app-deployment -c app-app"
        type: string
        required: true

jobs:
  build:
    name: "Build"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    outputs:
      build_number: ${{ steps.export_build_tag.outputs.build_number }}
    steps:

      - name: "Checkout"
        id: checkout
        uses: actions/checkout@v3

      - name: "Setup Node 10.21"
        id: setup_node
        uses: actions/setup-node@v3
        with:
          node-version: 10.21
          cache: 'npm'
          cache-dependency-path: linced-*/package-lock.json
          registry-url: "https://npm.pkg.github.com"

      - name: "Login to ACR"
        id: login_to_acr
        uses: docker/login-action@v2
        with:
          registry: linced.azurecr.io
          username: ${{ secrets.AZURE_ACR_LINCED_USERNAME }}
          password: ${{ secrets.AZURE_ACR_LINCED_PASSWORD }}

      - name: "Install Dependencies (npm ci)"
        id: install_dependencies
        run: |
          cd linced-*
          npm ci
        env:
          NODE_AUTH_TOKEN: ${{ github.token }}

      - name: "Set Branch Environment Variables"
        id: set_branch_environment_variables
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        uses: iamtheyammer/branch-env-vars@v1.2.1
        with:
          bevOverwrite: true
          bevSetEmptyVars: true
          APP_FQDN: |
            testing:${{secrets.DEVELOPMENT_APP_FQDN}}
            development:${{secrets.DEVELOPMENT_APP_FQDN}}
            staging:${{secrets.STAGING_APP_FQDN}}
            production:${{secrets.PRODUCTION_APP_FQDN}}

      - name: "Lint JavaScript"
        id: lint_js
        run: |
          cd linced-*
          npm run lint:js

      - name: "Lint Handlebar Templates"
        id: lint_hbs
        run: |
          cd linced-*
          npm run lint:hbs

      # TODO: Get working tests one day
#      - name: "Run Ember Tests"
#        id: run_ember_tests
#        run: |
#          cd linced-*
#          npm run test

      - name: "Ember CLI Install"
        id: ember_cli_install
        run: |
          npm install -g ember-cli@3.16
          which ember || echo "Could not find 'ember'"
          which ember

      - name: "Ember Build"
        id: ember_build
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        env:
          BUILD: ${{ github.run_number }}
        run: |
          cd linced-*

          # Create build version
          export BUILD_NUM=$(( $BUILD + 10000 ))
          export APP_VERSION=$( echo "${{ github.ref_name }}.${BUILD_NUM}" | tr '/' '-')
          echo "Linced Build Version: ${APP_VERSION}"

          # Install
          ember build --environment ${{ github.ref_name }}

          # Post install stuff and things.
          cd dist/assets
          mkdir update
          cp linced-*.* update/ || true
          cp vendor-*.* update/ || true

      - name: "Create Sentry Release"
        id: create_sentry_release
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ github.event.repository.name }}
          # SENTRY_URL: https://sentry.io/
          BUILD: ${{ github.run_number }}
        run: |
          cd linced-*
          
          # Download sentry cli
          curl -sL https://sentry.io/get-cli/ | SENTRY_CLI_VERSION=2.0.4 bash

          # Setup ENV vars for release
          export BUILD_NUM=$(( $BUILD + 10000 ))
          export APP_VERSION="$( echo "${{ github.ref_name }}.${BUILD_NUM}" | tr '/' '-')"
          export APP_RELEASE="${{github.event.repository.name}}@${APP_VERSION}"
          
          sentry-cli releases new $APP_RELEASE
          sentry-cli releases files $APP_RELEASE upload-sourcemaps ./dist
          sentry-cli releases finalize $APP_RELEASE
          
          # Cleanup
          rm -rf $(find dist/ -type f -name "*.map")

        # NOTE: We copy the previous assets in to smooth clients' transition from the old build to the new.
        # Else sometimes a client can use cached HTML from a previous build which tries to fetch the previous assets.
        # This partially makes up for a lack of CDN...Still not stellar
      - name: "Add Previous Assets"
        id: add_previous_assets
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        # Uncomment this when a new environment needs building and there is no pre-existing image to pull from
        # continue-on-error: true
        env:
          CONTAINER_REGISTRY: linced.azurecr.io/linc-ed
        run: |
          IMAGE_TAG="$CONTAINER_REGISTRY/${{ github.event.repository.name }}:${{ github.ref_name }}"
          docker pull $IMAGE_TAG
          docker run -d --rm --name "previous_assets" --entrypoint "" $IMAGE_TAG sleep infinity
          docker cp previous_assets:/usr/share/nginx/html/assets/update ./previous_assets
          docker rm --force previous_assets
          ls -la ./**/dist/assets || true
          cp -u ./previous_assets/linced-*.* ./**/dist/assets/ || true
          cp -u ./previous_assets/vendor-*.* ./**/dist/assets/ || true
          ls -la ./**/dist/assets || true

      - name: "Set Ownership"
        id: set_ownership
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        run: sudo chown -Rv 101:101 ./linced-*/dist/*

      - name: "Set up Docker Buildx"
        id: set_up_docker_buildx
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        uses: docker/setup-buildx-action@v2

      - name: "Export Build Tag"
        id: export_build_tag
        uses: linc-technologies/.github/.github/actions/build_label@master

      - name: "Build and export to Docker (Environmental Tags)"
        id: build_and_export_to_docker_environmental_tags
        uses: docker/build-push-action@v4
        if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
        with:
          context: .
          push: true
          tags: |
            ${{ steps.export_build_tag.outputs.docker_build_number }}
            ${{ steps.export_build_tag.outputs.docker_build_branch }}
          file: Dockerfile.drone

      - name: "Debug Steps Context"
        if: success() || failure()
        env:
          STEPS: ${{ toJson(steps) }}
        run: echo $STEPS

      - name: "Slack Notify"
        if: success() || failure()
        uses: linc-technologies/.github/.github/actions/slack_notify@master
        continue-on-error: true
        with:
          event: build
          success: ${{ !contains(steps.*.conclusion, 'failure') }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}


  deploy:
    name: "Deploy"
    if: contains(fromJson('["testing", "development", "staging", "production"]'), github.ref_name)
    environment: ${{ github.ref_name }}
    runs-on: ubuntu-latest
    needs: [build]
    steps:

      - name: "Checkout"
        id: checkout
        uses: actions/checkout@v3
        with:
          repository: linc-technologies/helm
          token: ${{ secrets.CICD_TOKEN }}

      - name: "Install Kubectl"
        id: install_kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.25.5'

      # If we're deploying from a non-production branch, configure Kubectl with Dev cluster secrets
      - name: "Configure Kubectl (development-au-east)"
        id: configure_kubectl_development_au_east
        if: ${{ github.ref != 'refs/heads/production' }}
        uses: linc-technologies/.github/.github/actions/k8s_auth@master
        with:
          server: ${{ secrets.DEVELOPMENT_AU_EAST_AKS_SERVER }}
          token: ${{ secrets.DEVELOPMENT_AU_EAST_AKS_TOKEN }}
          cert: ${{ secrets.DEVELOPMENT_AU_EAST_AKS_CERT }}

      # If we're deploying from a production branch, configure Kubectl with Prod cluster secrets
      - name: "Configure Kubectl (production-au-east)"
        id: configure_kubectl_production_au_east
        if: ${{ github.ref == 'refs/heads/production' }}
        uses: linc-technologies/.github/.github/actions/k8s_auth@master
        with:
          server: ${{ secrets.PRODUCTION_AU_EAST_AKS_SERVER }}
          token: ${{ secrets.PRODUCTION_AU_EAST_AKS_TOKEN }}
          cert: ${{ secrets.PRODUCTION_AU_EAST_AKS_CERT }}

      - name: "Kubectl Version"
        id: kubectl_version
        run: kubectl version

      - name: "Release Name"
        id: release_name
        run: |
          NAME=$(echo "${{ github.event.repository.name }}" | sed -e 's/linced-//g')
          
          # Accomodate for service and app with the same name
          if [ "$NAME" == "enrolments" ]; then 
            NAME="enrol"; 
          fi
          
          echo "release_name=${NAME}" >> $GITHUB_OUTPUT

      - name: "Helm Deploy"
        id: helm_deploy
        uses: linc-technologies/.github/.github/actions/deploy_helm@master
        with:
          chart: "app"
          release: ${{ steps.release_name.outputs.release_name }}
          namespace: ${{ github.ref_name }}
          tag: ${{ needs.build.outputs.build_number }}
          oci_user: ${{ secrets.AZURE_ACR_LINCED_USERNAME }}
          oci_pass: ${{ secrets.AZURE_ACR_LINCED_PASSWORD }}

      - name: "Slack Notify"
        if: success() || failure()
        uses: linc-technologies/.github/.github/actions/slack_notify@master
        continue-on-error: true
        with:
          event: deploy
          success: ${{ !contains(steps.*.conclusion, 'failure') }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

  iiiii:
    if: ${{ always() }}
    needs: [build, deploy]
    uses: ./.github/workflows/validate.yml
    with:
      jobs: ${{ toJSON(needs.*.result) }}
